---
title: Awaiting Flows
---
With the [state machine analogy](/runtime#state-machines) in mind, we can now look closely at composing flows. The goal
is to understand how to chain them.

To put it simply, how does one flow, await on another flow's result?

To begin with, it'd be weird for a flow to wait for a `ScheduledFlow`, especially when the it might not ever finish.
Meaning you can only await a `FlowExecutor`.

### FlowExecutor
We covered a lot about it in the last section when we were learning about [lazy evaluation](/flows-102#lazy-evaluation). But we didn't get a chance to look at its interface:
```typescript
class FlowExecutor<RT, M> {
	run(): void;
	await(): RT;
}
```

The type argument `RT` captures the return type of the [FlowFunction](/flows-102#flowfunction) that spawned it, `M` we can ignore for now.

We have been using `run()` everywhere, but a `FlowExecutor` gives you `await(): RT` to await the flow, out of the box.

Here's an example:
```typescript
class Main {
	hello() {
		const flow = std.flow<Main>("Print!", this).world("Hello");
		this.print(flow);
	}

	world(arg: string) {
		return `${arg} World!`;
	}

	print(flow: std.FlowExecutor<string, Main['world']>) {
		const result = flow.await(); // We can 'await' a flow and get its result.
		std.log(result);
	}
}
```
The line `const result = flow.await();` will make the currently executing flow suspend until the awaited flow
is complete.

<Note>This is similar to async/await features that exist in other languages.</Note>

<video
  muted
  playsInline
  controls
  className="w-full aspect-video"
  src="/videos/suspended.mp4"
></video>

<Tip>
	If you await a flow, it will count as calling that method(`FlowFunction`) and hence an edge would be rendered.

	Try [playing](https://app.metz.sh/try) with `run()` and `await()` and see how the playground changes!
</Tip>

## Awaiting multiple flows

In real systems, you are often awaiting multiple things simultaneously, or racing them together.
That's exactly why we have `std.awaitAll()` and `std.awaitRace()`.

### `std.awaitAll`
This is the equivalent of JavaScript's [Promise.all](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all). It takes an array of `FlowExecutor` and returns another array
corresponding to result values. For example:
```typescript
const result = std.awaitAll([
	flow1,
	flow2,
	flow3,
]);

std.log(result);
// Assuming all the flows returned 42. The above statement would log [42,42,42]
```

### `std.awaitRace`
This is the equivalent of JavaScript's [Promise.race](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race).
It also takes an array of `FlowExecutor` but returns a single value corresponding to the flow which completed first. If a flow wins the race, the remaining flows are cancelled.
For example:
```typescript
const result = std.awaitRace([
	flow1,
	flow2,
	flow3,
]);

std.log(result);
// Assuming all the flows return 42, and flow3 completed first.
// The above statement would log 42
```

Here's how it looks like in action:
<Frame>
    <iframe width="900px" height="600px" src="https://app.metz.sh/play/0284bdeb68494872a1b2a8b993290d18?minimal=true" />
</Frame>
You can play with the code [here](https://app.metz.sh/try?templateId=5).

<br/>
We have one last mechanism left, events. The tried and tested mechanism for asynchronousity. Let's cover that in next section!
