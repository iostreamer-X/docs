---
title: Stories
---

Say we created a simple web server using NodeJS. Our `package.json` file will have a configuration called [main](https://docs.npmjs.com/cli/v10/configuring-npm/package-json#main),
telling the entrypoint to our code.
<br/>And if we dockerize our app, we will literally have an [entrypoint](https://docs.docker.com/reference/dockerfile/#entrypoint) which
will control what runs in the container.

And that's good starting point to introduce stories.

<video
  muted
  playsInline
  controls
  className="w-full aspect-video"
  src="/videos/story-creation.mp4"
></video>

At its very core, a story is what's responsible for running your code. It's very much an entrypoint to it.

In metz your code doesn't just run and get visualised, it's a story that gets rendered.
It's essentially a script where you can instantiate classes, write all sorts of setup code.
<br/>The execution of that script is what gets the ball rolling.

## More than an entrypoint
The key difference here, is that unlike entrypoints, you can have as many stories you want. In fact, that's the intended way.

Each story, tells a different <Tooltip tip="This is shameful but couldn't be helped.">story</Tooltip> about your code, your design.
This is where you comprehensively communicate all the edge cases, all the "What If?" questions and let your audience see every
angle of the designed system.

This ties quite neatly with the [Class based](/classes) approach we have. Each class represents data and behaviour, where they both can change each other.

Let's look at an example. Say we have an authentication system where the db can fail, and does things differently if it indeed fails.
To capture this, we can write the following code:

```typescript
class AuthenticationService {
	isDatabaseDown = false;

	authenticate(sessionToken: string) {
		if(this.isDatabaseDown) {
			return {
				type: 'error',
				message: 'Database is down!'
			}
		}

		return {
			type: 'response',
			message: 'User is authenticated!'
		}
	}
}
```

This is an oversimplification, but ignoring that for now. Let's focus on `isDatabaseDown` where if it's `false` all good, but if `true` then we get an error response.

And to cover both the cases, we can create two stories!
<br/> One where `isDatabaseDown` is `false` and anothere where it's `true`.

<CodeGroup>

```typescript First Script
const service = new AuthenticationService();
std.flow("DB is up", service).authenticate('123').run();
```

```typescript Second Script
const service = new AuthenticationService();
service.isDatabaseDown = true;
std.flow("DB is down", service).authenticate('123').run();
```
</CodeGroup>
<br/>
<br/>
Here's an example of a system which depends on stripe. The first story showcases how a particular condition can cause
two different entries in our system for the same payment.
<br/>From the **'Stories'** dropdown, choose the other story to see how the system behaves normally.

<Frame>
    <iframe width="900px" height="700px" src="https://app.metz.sh/play/0286b754d9e4408ba172e344eeac47b9" />
</Frame>
<Card horizontal title="Click here to open in a tab" icon="link" href="https://app.metz.sh/play/0286b754d9e4408ba172e344eeac47b9">
  Things might be squished here!
</Card>


## Advantage
Each story, is the exection of same underlying code but under different conditions.
<br/>Just write a script, change the initial conditions, and you get a completely new perspective of the design, without repeating yourself.

<br/>
But what's the `std.flow` business? We have seen that before, but what does it do?. Why does it have that weird syntax?

Well, let's find out in the next section!
